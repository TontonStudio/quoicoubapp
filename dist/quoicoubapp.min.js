/** * Configuration de l'application Quoicoubapp * Contient les constantes, mappings et paramètres globaux */const Config = {version: '1.2.0',debug: false,keywordPatterns: {'pourquoi': /\bpourquoi\b/i,'qui': /(\s|^)qui(\s|$|\?|\.)/i,'comment': /\bcomment\b/i,'hein': /\bhein\b|(\s|^)(un|ben|1)(\s|$|\?|\.)|\b\w+bah\b|(\s|^)(fin|vin|lin|pin|brin|train|main|pain|plein|sein|frein|teint|daim|faim|rein|saint|grain|bain|gain|nain|bien|rien|chien|mien|tien|sien|loin|soin|coin|besoin|terrain|demain|lendemain|prochain|cousin|voisin|matin|malin|butin|poulain)(\s|$|\.|\?|\!)/i,'quoi': /\bquoi\b|\bqu[oa]i\b/i},soundMapping: {'pourquoi': ['./sounds/pourquoicarabinga/pourquoicarabinga.mp3'],'qui': ['./sounds/quiquiriqui/quiquiriqui1.mp3'],'comment': ['./sounds/commandantdebord/commandantdebord.mp3'],'hein': ['./sounds/apanyans/apanyan1.mp3','./sounds/apanyans/apanyan2.mp3','./sounds/apanyans/apanyan3.mp3','./sounds/apanyans/apanyan4.mp3','./sounds/apanyans/apanyan5.mp3','./sounds/apanyans/apanyan6.mp3','./sounds/apanyans/apanyan7.mp3','./sounds/apanyans/apanyan8.mp3','./sounds/apanyans/apanyan9.mp3','./sounds/apanyans/apanyan10.mp3'],'quoi': ['./sounds/quoicoubeh/quoicoubeh1.mp3','./sounds/quoicoubeh/quoicoubeh2.mp3','./sounds/quoicoubeh/quoicoubeh3.mp3','./sounds/quoicoubeh/quoicoubeh4.mp3','./sounds/quoicoubeh/quoicoubeh5.mp3','./sounds/quoicoubeh/quoicoubeh6.mp3','./sounds/quoicoubeh/quoicoubeh7.mp3']},vibrationPatterns: {'pourquoi': [50, 50, 100],'qui': [50, 100, 50],'comment': [50, 100, 50],'hein': [100, 50, 50],'quoi': [50, 50, 50, 50]},speech: {lang: 'fr-FR',continuous: true,interimResults: true, maxAlternatives: 1},delays: {restartRecognition: 100, retryAfterError: 150,networkErrorRetry: 1000, soundEndRestart: 100 },optimization: {lazyPreload: true,initialPreloadCount: 1},maxRetries: 3};function log(message, forceShow = false) {if (Config.debug || forceShow) {console.log(`[Quoicoubapp] ${message}`);}}/** * Gestionnaire de cache audio * Précharge et stocke les objets Audio pour une lecture plus rapide */const AudioCache = {_cache: new Map(),/** * Précharge et met en cache les sons au démarrage * @param {Object} soundMappings - Mappings des mots-clés vers les sons * @returns {Promise} - Promesse résolue lorsque tous les sons sont préchargés */async preload(soundMappings) {const promises = [];for (const [keyword, soundList] of Object.entries(soundMappings)) {if (!Array.isArray(soundList) || soundList.length === 0) continue;if (Config.optimization.lazyPreload) {const count = Math.min(Config.optimization.initialPreloadCount, soundList.length);for (let i = 0; i < count; i++) {const promise = this.loadSound(soundList[i]);promises.push(promise);}} else {for (const soundPath of soundList) {const promise = this.loadSound(soundPath);promises.push(promise);}}}return Promise.allSettled(promises);},/** * Charge un son dans le cache * @param {string} path - Chemin du fichier audio * @returns {Promise} - Promesse résolue avec l'objet Audio */loadSound(path) {return new Promise((resolve, reject) => {if (this._cache.has(path)) {resolve(this._cache.get(path));return;}const audio = new Audio();audio.addEventListener('canplay', () => {this._cache.set(path, audio);resolve(audio);}, { once: true });audio.onerror = (error) => {log(`Erreur de préchargement de l'audio: ${path}`, true);reject(error);};audio.src = path;audio.load();setTimeout(() => {if (!this._cache.has(path)) {this._cache.set(path, audio);resolve(audio);}}, 1000);});},/** * Obtient un son préchargé du cache, ou le charge si nécessaire * @param {string} path - Chemin du fichier audio * @returns {Audio} - Objet Audio (existant ou nouvellement créé) */get(path) {if (!this._cache.has(path)) {const audio = new Audio(path);this._cache.set(path, audio);audio.load();}return this._cache.get(path);},/** * Vérifie si un son est dans le cache * @param {string} path - Chemin du fichier audio * @returns {boolean} - Vrai si le son est dans le cache */has(path) {return this._cache.has(path);}};/** * Gestionnaire de reconnaissance vocale * Gère l'écoute, la détection des mots-clés et la gestion des événements de reconnaissance */const SpeechManager = {recognition: null,isListening: false,manuallyDisabled: false,retryCount: 0,onKeywordDetected: null,keywordPatterns: {},lastTranscript: "",processingKeyword: false,/** * Initialise le gestionnaire de reconnaissance vocale * @param {Object} keywordPatterns - Mapping des mots-clés avec expressions régulières * @param {Function} onKeywordDetected - Callback appelée quand un mot-clé est détecté */init(keywordPatterns, onKeywordDetected) {this.keywordPatterns = keywordPatterns;this.onKeywordDetected = onKeywordDetected;this.prepareRecognition();log('SpeechManager initialisé');},/** * Prépare l'objet de reconnaissance vocale * @returns {boolean} - Vrai si l'initialisation a réussi */prepareRecognition() {try {const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;this.recognition = new SpeechRecognition();this.recognition.continuous = Config.speech.continuous;this.recognition.interimResults = Config.speech.interimResults;this.recognition.maxAlternatives = Config.speech.maxAlternatives;this.recognition.lang = Config.speech.lang;this.recognition.onresult = this.handleResult.bind(this);this.recognition.onerror = this.handleError.bind(this);this.recognition.onend = this.handleEnd.bind(this);this.recognition.onaudiostart = this.handleAudioStart.bind(this);return true;} catch (error) {log("Erreur d'initialisation de la reconnaissance vocale: " + error, true);return false;}},/** * Démarre l'écoute * @returns {boolean} - Vrai si le démarrage a réussi */start() {if (this.isListening) return false;try {if (!this.recognition && !this.prepareRecognition()) {return false;}this.recognition.start();this.isListening = true;this.manuallyDisabled = false;this.retryCount = 0;this.processingKeyword = false;log('Reconnaissance vocale démarrée');return true;} catch (error) {log("Erreur de démarrage de la reconnaissance vocale: " + error, true);this.resetRecognition();return false;}},/** * Arrête l'écoute * @returns {boolean} - Vrai si l'arrêt a réussi */stop() {if (!this.isListening) return true;try {this.recognition.stop();this.isListening = false;log('Reconnaissance vocale arrêtée');return true;} catch (error) {log("Erreur d'arrêt de la reconnaissance vocale: " + error, true);this.resetRecognition();return false;}},/** * Réinitialise la reconnaissance vocale */resetRecognition() {if (this.recognition) {try {this.recognition.abort();} catch (e) {}}this.recognition = null;this.isListening = false;this.prepareRecognition();log('Reconnaissance vocale réinitialisée');},/** * Gestionnaire de résultat de reconnaissance vocale * @param {SpeechRecognitionEvent} event - Événement de résultat de reconnaissance */handleResult(event) {if (this.processingKeyword) return;if (!event.results || event.results.length === 0) return;const result = event.results[event.results.length - 1];if (!result || result.length === 0) return;const transcript = result[0].transcript.trim().toLowerCase();if (!transcript) return;if (transcript === this.lastTranscript) return;this.lastTranscript = transcript;log(`Transcription: ${transcript}`);for (const [keyword, pattern] of Object.entries(this.keywordPatterns)) {if (pattern.test(transcript)) {log(`Mot-clé détecté: ${keyword}`);this.processingKeyword = true;this.stop();if (typeof this.onKeywordDetected === 'function') {this.onKeywordDetected(keyword, transcript);}return;}}},/** * Gestionnaire d'erreur de reconnaissance vocale * @param {SpeechRecognitionErrorEvent} event - Événement d'erreur de reconnaissance */handleError(event) {log("Erreur de reconnaissance vocale: " + event.error, true);this.processingKeyword = false;if (event.error === 'no-speech' || event.error === 'audio-capture') {this.retryCount++;if (this.retryCount <= Config.maxRetries) {setTimeout(() => {if (!this.manuallyDisabled) {this.resetRecognition();this.start();}}, Config.delays.retryAfterError);} else {this.resetRecognition();}} else if (event.error === 'network') {setTimeout(() => {if (!this.manuallyDisabled) {this.resetRecognition();this.start();}}, Config.delays.networkErrorRetry);} else {this.resetRecognition();}},/** * Gestionnaire de fin de reconnaissance */handleEnd() {log('Fin de session de reconnaissance vocale');if (this.isListening && !this.manuallyDisabled && !this.processingKeyword) {setTimeout(() => {try {this.recognition.start();log('Reconnaissance redémarrée après fin');} catch (e) {log('Erreur lors du redémarrage: ' + e);this.resetRecognition();setTimeout(() => {if (!this.manuallyDisabled) {this.prepareRecognition();this.start();}}, Config.delays.retryAfterError);}}, Config.delays.restartRecognition);}},/** * Gestionnaire de début de capture audio */handleAudioStart() {log('Début de la capture audio');this.retryCount = 0; this.processingKeyword = false; },/** * Définit manuellement l'état d'écoute * @param {boolean} disabled - Vrai pour désactiver manuellement l'écoute */setManualDisabled(disabled) {this.manuallyDisabled = disabled;this.processingKeyword = false;log(`Écoute manuelle ${disabled ? 'désactivée' : 'activée'}`);}};/** * Gestionnaire de sons * Gère la lecture et les événements audio */const SoundManager = {isSoundPlaying: false,currentSound: null,lastPlayedKeyword: null,soundMapping: {},onSoundEnd: null,audioBuffers: {}, /** * Initialise le gestionnaire de sons * @param {Object} soundMapping - Mapping des mots-clés vers les sons * @param {Function} onSoundEnd - Callback appelée quand un son se termine */init(soundMapping, onSoundEnd) {this.soundMapping = soundMapping;this.onSoundEnd = onSoundEnd;const mainSounds = [];for (const [keyword, sounds] of Object.entries(soundMapping)) {if (Array.isArray(sounds) && sounds.length > 0) {mainSounds.push(sounds[0]);}}setTimeout(() => {AudioCache.preload(soundMapping).then(results => {log(`Préchargement audio terminé: ${results.length} sons traités`);}).catch(error => {log('Erreur lors du préchargement des sons: ' + error, true);});}, 100);for (const sound of mainSounds) {const audio = new Audio(sound);audio.load();this.audioBuffers[sound] = audio;}log('SoundManager initialisé');},/** * Obtient un son aléatoire pour un mot-clé * @param {string} keyword - Mot-clé pour lequel obtenir un son * @returns {string|null} - Chemin du son aléatoire */getRandomSound(keyword) {const sounds = this.soundMapping[keyword];if (!Array.isArray(sounds) || sounds.length === 0) {return null;}const randomIndex = Math.floor(Math.random() * sounds.length);return sounds[randomIndex];},/** * Joue un son pour un mot-clé * @param {string} keyword - Mot-clé pour lequel jouer un son * @returns {boolean} - Vrai si la lecture a démarré */play(keyword) {if (this.isSoundPlaying) {log('Un son est déjà en cours de lecture, ignoré: ' + keyword);return false; }try {const soundPath = this.getRandomSound(keyword);if (!soundPath) {log(`Aucun son disponible pour le mot-clé: ${keyword}`, true);return false;}log(`Lecture du son: ${soundPath}`);this.isSoundPlaying = true;this.lastPlayedKeyword = keyword;let audioElement;if (this.audioBuffers[soundPath]) {audioElement = this.audioBuffers[soundPath];audioElement.currentTime = 0;}else if (AudioCache.has(soundPath)) {audioElement = AudioCache.get(soundPath);audioElement.currentTime = 0;}else {audioElement = new Audio(soundPath);audioElement.preload = 'auto';this.audioBuffers[soundPath] = audioElement;}this.currentSound = audioElement;const onEndedHandler = this.handleSoundEnd.bind(this);const onErrorHandler = this.handleSoundError.bind(this);audioElement.onended = onEndedHandler;audioElement.onerror = onErrorHandler;audioElement.play().catch(error => {log('Erreur de lecture audio: ' + error, true);this.handleSoundError(error);});return true;} catch (error) {log('Erreur lors de la lecture du son: ' + error, true);this.handleSoundError(error);return false;}},/** * Gestionnaire de fin de son */handleSoundEnd() {log('Son terminé: ' + this.lastPlayedKeyword);this.isSoundPlaying = false;this.currentSound = null;if (typeof this.onSoundEnd === 'function') {this.onSoundEnd(this.lastPlayedKeyword);}},/** * Gestionnaire d'erreur de lecture audio * @param {Error} error - Erreur de lecture */handleSoundError(error) {log('Erreur de lecture audio: ' + error, true);this.isSoundPlaying = false;this.currentSound = null;if (typeof this.onSoundEnd === 'function') {this.onSoundEnd(this.lastPlayedKeyword);}},/** * Arrête la lecture du son actuel */stop() {if (this.currentSound) {try {this.currentSound.pause();this.currentSound.currentTime = 0;log('Lecture audio arrêtée');} catch (e) {log('Erreur lors de l\'arrêt du son: ' + e, true);}this.isSoundPlaying = false;this.currentSound = null;}}};/** * Gestionnaire de l'interface utilisateur * Gère les interactions et les mises à jour de l'interface */const UIManager = {elements: {},/** * Initialise l'interface utilisateur * @returns {Object} - Éléments DOM de l'interface */init() {this.elements = {listenButton: document.getElementById('listenButton'),statusElement: document.getElementById('status'),resultElement: document.getElementById('result'),indicatorElement: document.getElementById('indicator'),currentSoundElement: document.getElementById('currentSound'),audioContainer: document.getElementById('audioContainer')};this.elements.listenButton.addEventListener('selectstart', e => e.preventDefault());this.elements.listenButton.addEventListener('touchmove', e => e.preventDefault(), { passive: false });log('UIManager initialisé');return this.elements;},/** * Met à jour l'état de l'interface (écoute active/inactive) * @param {boolean} isListening - Vrai si l'écoute est active */updateListeningState(isListening) {const { listenButton, statusElement, indicatorElement } = this.elements;if (isListening) {statusElement.textContent = "Écoute en cours...";indicatorElement.style.display = 'inline-block';listenButton.textContent = "Arrêter l'écoute";listenButton.classList.add('stop');} else {statusElement.textContent = "En attente";indicatorElement.style.display = 'none';listenButton.textContent = "Commencer l'écoute";listenButton.classList.remove('stop');}},/** * Met à jour l'état de l'interface pendant la lecture d'un son * @param {boolean} isPlaying - Vrai si un son est en cours de lecture * @param {string} soundPath - Chemin du son en cours de lecture */updatePlayingState(isPlaying, soundPath = null) {const { statusElement, currentSoundElement } = this.elements;if (isPlaying) {statusElement.textContent = "Lecture du son en cours...";if (soundPath) {currentSoundElement.textContent = `Son: ${soundPath}`;currentSoundElement.style.display = 'block';}} else {currentSoundElement.style.display = 'none';}},/** * Met à jour l'état de l'interface en cas d'erreur * @param {string} message - Message d'erreur à afficher */showError(message) {const { statusElement, indicatorElement } = this.elements;statusElement.textContent = message || "Une erreur est survenue";indicatorElement.style.display = 'none';log('Erreur affichée: ' + message, true);},/** * Vibre (si disponible) pour donner un feedback tactile * @param {number|Array} pattern - Durée ou motif de vibration */vibrate(pattern) {if (navigator.vibrate) {navigator.vibrate(pattern);}},/** * Met à jour l'affichage de la transcription (en mode debug) * @param {string} text - Texte de la transcription */updateTranscription(text) {if (Config.debug && this.elements.resultElement) {this.elements.resultElement.textContent = text;this.elements.resultElement.style.display = 'block';}}};/** * Application principale Quoicoubapp * Point d'entrée et orchestration des différents composants */const App = {/** * Initialisation de l'application */init() {const ui = UIManager.init();SoundManager.init(Config.soundMapping, (keyword) => {if (!SpeechManager.manuallyDisabled) {SpeechManager.start();UIManager.updateListeningState(true);} else {UIManager.updateListeningState(false);}UIManager.updatePlayingState(false);});SpeechManager.init(Config.keywordPatterns, (keyword, transcript) => {log(`Mot-clé détecté: ${keyword} (${transcript})`);UIManager.vibrate(Config.vibrationPatterns[keyword] || [50, 50]);UIManager.updateListeningState(false);UIManager.updateTranscription(transcript);const soundPath = SoundManager.getRandomSound(keyword);if (soundPath) {UIManager.updatePlayingState(true, soundPath);SoundManager.play(keyword);}});this.setupEventListeners();setTimeout(() => {if (this.hasUserMediaPermission()) {try {SpeechManager.start();UIManager.updateListeningState(true);} catch (e) {log("Démarrage automatique impossible, attente du clic utilisateur", true);}}}, 200);this.checkEnvironment();log(`Application Quoicoubapp v${Config.version} initialisée`, true);},/** * Vérifie si l'autorisation microphone a déjà été accordée * @returns {boolean} - Vrai si l'autorisation est déjà accordée */hasUserMediaPermission() {return navigator.mediaDevices &&navigator.permissions &&navigator.permissions.query ? true : false;},/** * Configure les écouteurs d'événements avec optimisation */setupEventListeners() {const { listenButton } = UIManager.elements;listenButton.addEventListener('click', () => {UIManager.vibrate(20); if (SpeechManager.isListening) {SpeechManager.setManualDisabled(true);SpeechManager.stop();UIManager.updateListeningState(false);} else {SpeechManager.setManualDisabled(false);if (!SoundManager.isSoundPlaying) {const started = SpeechManager.start();UIManager.updateListeningState(started);if (!started) {UIManager.showError("Impossible de démarrer la reconnaissance vocale");}}}});if (typeof document.hidden !== "undefined") {document.addEventListener("visibilitychange", () => {if (document.hidden) {if (SpeechManager.isListening) {log('App en arrière-plan, arrêt temporaire de l\'écoute');SpeechManager.stop();}} else {if (!SpeechManager.manuallyDisabled && !SoundManager.isSoundPlaying) {log('App de nouveau visible, reprise de l\'écoute');SpeechManager.start();UIManager.updateListeningState(SpeechManager.isListening);}}}, false);}window.addEventListener('blur', () => {if (SpeechManager.isListening) {log('Perte de focus, arrêt temporaire de l\'écoute');SpeechManager.stop();}}, { capture: true });window.addEventListener('focus', () => {if (!SpeechManager.manuallyDisabled && !SoundManager.isSoundPlaying) {log('Récupération du focus, reprise de l\'écoute');SpeechManager.start();UIManager.updateListeningState(SpeechManager.isListening);}}, { capture: true });document.body.addEventListener('touchstart', () => {if (window.AudioContext || window.webkitAudioContext) {const AudioContext = window.AudioContext || window.webkitAudioContext;const audioCtx = new AudioContext();const oscillator = audioCtx.createOscillator();const gainNode = audioCtx.createGain();gainNode.gain.value = 0;oscillator.connect(gainNode);gainNode.connect(audioCtx.destination);oscillator.start();oscillator.stop(audioCtx.currentTime + 0.001);}}, { once: true, passive: true });},/** * Vérifie l'environnement (PWA installée, WebView, etc.) * @returns {Object} - Informations sur l'environnement */checkEnvironment() {const isPWA = window.matchMedia('(display-mode: standalone)').matches ||window.navigator.standalone === true;const userAgent = navigator.userAgent.toLowerCase();const isWebView = userAgent.indexOf('android') > -1 && userAgent.indexOf('wv') > -1;if (isPWA) {log('Application lancée en mode PWA installée');if (SoundManager.preloadMoreSounds) {SoundManager.preloadMoreSounds();}}if (isWebView) {log('Application lancée dans une WebView Android');document.body.classList.add('webview-mode');}const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;if (isIOS) {log('Application lancée sur iOS');document.body.classList.add('ios-device');}return { isPWA, isWebView, isIOS };}};if ('serviceWorker' in navigator) {navigator.serviceWorker.getRegistrations().then(function(registrations) {for(let registration of registrations) {registration.unregister();}});}if (document.readyState === 'loading') {document.addEventListener('DOMContentLoaded', App.init.bind(App));} else {App.init();}